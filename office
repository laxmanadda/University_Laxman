  https://git-scm.com/book/en/v1/Git-Basics-Undoing-Things
  
  https://github.com/arialdomartini/Back-End-Developer-Interview-Questions
  
  try to clean and make it look good(project)

spring rest api
hibernate,mysql and mongodb --when and why to use
git

friends referral(search in linkedin who is working in which company)
linkedin kgp alumni group
fb referral group
angellist.co and linkedin
glassdoor/naukri

you are giving very less time for each topic that you are not able to per fect it. give more time to a topic


spring
databases(mysql,hibernate,mongodb if there is time) -- procedures,functions,indexing,views,triggers,joins
oops concepts
data structures
rest/http/catching


joins--> join/inner join,outer join(left,right,full),natural join,cross join,self join,equi join,theta join
joins means joining 2 or more tables where the joining clause can be =,!=,>,<,>=,<=.
equi join is any join with join clause as "="
theta join is complement to equi join(anything other than "=")

https://stackoverflow.com/questions/17946221/sql-join-and-different-types-of-joins
self join --> http://www.mysqltutorial.org/mysql-self-join/

views --> run any query(with conditions,joins.....anything) and store them as a view. just like creating a new table.
https://stackoverflow.com/questions/1278521/why-do-you-create-a-view-in-a-database
https://www.w3schools.com/sql/sql_view.asp

indexing --> https://www.geeksforgeeks.org/indexing-in-databases-set-1/

constraints vs triggers: https://dba.stackexchange.com/questions/151881/how-do-triggers-and-check-constraints-relate-to-maitaining-database-rules

https://stackoverflow.com/questions/21077898/why-are-relational-databases-unsuitable-for-unstructured-data
https://www.tutorialspoint.com/jsp/jsp_file_uploading.htm -->file upload
https://news.ycombinator.com/item?id=12292134
important things are databases and spring and oops and DS
rest everything just understand basics

https://www.javatpoint.com/spring-java-mail-tutorial --multiple recipients
public void send_mail(String situation) {
		if(situation.equals("start_process"){
			students+mac
		}else if(situation.equals("program_offered") || situation.equals("program_scheduled")){
			students mac
		}else if(situation.equals("applied")){
			student and mac
		}else if(situation.equals("approved for interview")){
			student
		}else if(situation.equals("confirmed")){
			student
		}
		
		ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml");
		MailMail m= (MailMail) context.getBean("mailMail");
		
		String sender="addalaxman@gmail.com";//write here your id
		String receiver="laxmanadda26@gmail.com";//write here receiver id
		m.sendMail(sender,receiver,"hi","welcome");
		
		System.out.println("success");
	}
	
When Git stores a new version of a project, it stores a new tree 
It is built to be worked on simultaneously by many people, having multiple branches developed by individual developers, being merged, branched and re-merged constantly. 
SHA-1 value



clone fetch pull remote rebasing forking branching checkout
fork vs branch


file upload and saving
cookies(1st and 3rd party)
spa(how it is diff from ajax)
migration from mysql to postgresql
git (fetch pull branching merging )

what is api endpoint
https://github.com/arialdomartini/Back-End-Developer-Interview-Questions
https://gist.github.com/jaseemabid/1321592


https://dzone.com/articles/building-simple-restful-api
https://stackoverflow.com/questions/2122604/what-is-an-endpoint
https://spring.io/guides/gs/consuming-rest/

understand http methods
testing university project with thousand of request simultaneously -->JMeter
build rest api with spring and spark
use the rest api which we build in the above step 
spring jdbcTemplate
why hibernate why spring
spring basics
rest basics internal working



First of all- microframeworks are not yet mainstream. That may soon change especially with the rapid growth of interest in the Serverless Architectures. 
Serverless really benefits from small and lightweight deployments- if you want to use Java in that context, microframeworks seem like a good choice.

Another big driver for their popularity is the increasing adoption of containers (Docker), containers management systems (Kubernetes) and patterns such as API Gateway. 
Suddenly, the services do not need to deal with as many problems as they used to.

https://dzone.com/articles/building-simple-restful-api
https://www.baeldung.com/spark-framework-rest-api
https://softwareengineering.stackexchange.com/questions/287819/should-you-write-your-back-end-as-an-api


maps
payment gateways
which framework/language/tool to use in what situation
4) instant messaging(also do some research on rabbitMQ)
2) storing media of customers
1) api building and using
3) create an app(can do it with eclipse no need for andriod studio)

https://medium.freecodecamp.org/the-secret-to-being-a-top-developer-is-building-things-heres-a-list-of-fun-apps-to-build-aac61ac0736c

jax-rs(and client api) and jax-b(xml data binding)
jersey(can be used for implementing jax-rs) and spark and unirest

https://www.reddit.com/r/java/comments/6ixhqe/recommendations_for_java_http_client_libraries/?depth=1
http://unirest.io/java.html
https://stackoverflow.com/questions/17980596/what-is-jaxb-and-jaxrs-how-are-they-related
https://docs.oracle.com/javaee/7/tutorial/jaxrs-client001.htm


truncate and drop --> no roll back
delete-->roll back

if u want to delete everything-->drop
if u want to remove only all records and no roll back --> truncate
if u want to remove all/some records and roll back --> delete

database vs schema
how to roll back after using delete command
transactions?
mysql engines(innodb,myisam)
to know which engine is being used--> 	USE <database>;
										SHOW TABLE STATUS\G 

set autocommit=0;-->when u add something and didn't commit it'll not get stored in the low level disk when session is ended;
select @@autocommit from dual;

any default query is a single statement autocommitted transaction; which means if you don't use 'start transaction' after every query statement commit is applied;
so to make bunch of query statements as a transaction following acid properties --> use start transaction,commit and roll back commands;

rollback; --> suppose u deleted rows in a table 1) when autocommit=1; --> you cannnot roll back
                                                2) when autocommit=0; -->

no fb,insta,youtube,masturbating
just work,sleep,marriage and applications

first matster mysql(simple commands to sql engine, 	joins indexing views functions)
then theory part of relational databases-->codds rules,keys(dependency),normal forms, relatinal calculus, query optimization, transactions

MA60050

tricky questions eg: where vs having

demos:

distinct :  SELECT distinct country,city FROM Customers; (distinct pair of country and city)
not clause : SELECT *FROM Customers where not country="Germany"
delete vs drop vs truncate mysql
https://www.geeksforgeeks.org/sql-ddl-dml-dcl-tcl-commands/

begin transaction

/*few sql commands*/

commit (once a transaction is in between begin and commit rollback is automatically done by mysql once an error occurs)

(all these are tcl commands)
commit
rollback
savepoint--rollback to a certain point rather than rolling back entire transaction
start transaction

These 2 things have to be understood very carefully and in depth...
deadlock in mysql transactions
locking of tables,rows

sql fiddle











Advanatges of Hibernate:

	fast --> cache feature
	HQL --> Database independent query language(if database name changed during the course of the project no need to change in the code)
	automatic table creation (https://stackoverflow.com/questions/21069687/hibernate-auto-create-database/37187483)
	simplifies joining tables(cascading)
	hides sql details for simple commands(simple select,insert,delete,update)
	
Hibernate is implementation of JPA(it defines how a ORM should function and other rules)

stages of a java object in hibernate(https://www.java4s.com/hibernate/life-cycle-of-pojo-class-objects-in-the-hibernate/):

1) Transition : newly created obj not saved(no relation with the database)
2) Persistent : saved in the database and associated with a session
3) Detached : saved in the database but not associated with a session.(session is closed)

https://www.tutorialspoint.com/hibernate/hibernate_sessions.htm
session obj is used to get a physical connection to the database. session obj is created and not left alone for a long time because they are thread safe(will update below)

session vs sessionFactory: session factory contains configuration details of the database. each database will have a sessionFactory while session will be for 
each transaction of a database. session stores 2nd level cache while sessionFactory stores 1st level cache.

SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();(if we have configuration file name different than hibernate.cfg.xml then we have to mention it inside configure() method)
This sessionFactory object will have all information whatever we have provided in hibernate.cfg.xml file

Named Query:

It's like alias. Giving some name to a query string and using it whenever we want.(https://www.javatpoint.com/hibernate-named-query)


Need some time to understand: cache Levels in hibernate: first,second and query caching
second level(by default switched off) and query caching(by default switched off) speeds our app.

Transactions in hibernate: 
same as in mysql--> we will start a transaction run multiple sql queries and commit at the end. if error we will roll back all the queries.(https://www.javatpoint.com/hibernate-transaction-management-example)

Mapping in hibernate:

Projections and criteriain hibernate: 

Java multithreading and thread safety:

polymorphic queries
